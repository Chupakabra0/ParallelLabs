# Лабораторная работа №1

## Отчёт по лабораторной работе №1

по дисциплине "Параллельные и распредлённые вычисления"<br/>
студента группы ПА-18-2<br/>
Сафиюлина Александра Александровича<br/>

### Постановка задачи:

* Напишите программу на языке C для вычисления скалярного произведения двух векторов типа ``double``;
* Размер векторов выберите таким образом, чтобы они занимали половину оперативной памяти;<br/>
* Модифицируйте данный алгоритм с помощью прагм OpenMP и выполните программу с использованием разного количества 
  потоков;
* Вычислите время выполнения и проанализируйте полученные результаты.

### Выполнение:

Создадим структуру ``Vector``, которая будет вектором заданой на этапе
компиляции размерности. А также вспомагательные функции,
которые будут конструировать, уничтожать и использовать
(поиск скалярного произведения) экземпляры ``Vector``.

Опишем объявления структуры и функций в файле ``Vector.h``,
определения - в ``Vector.c``

Ниже приводится код функции для поиска скалярного произведения
и определение структуры ``Vector``:

````C

#define DIMENSION 268435455ll

static long long i = 0ll;

typedef struct Vector {
	double x[DIMENSION];
} Vector;

double Scalar(const Vector* first, const Vector* second) {
    double result = 0.0;
    for (i = 0ll; i < DIMENSION; ++i) {
        result += first->x[i] * second->x[i];
    }
    return result;
}

````

Макро-константа ``DIMENSION`` была подобрана таким образом,
чтобы заполнить чуть меньше чем 4 Гб оперативной памяти
двумя векторами, скалярное произведение которых и будет искаться,
и была сохранена возможность построить приложение на компиляторах
GNU и MSVC.

Модифицируем функции прагмами из библиотеки OpenMP и
дадим возможность выбирать точное количество потоков, которые
будут принимать участие в работе программы, с помощью функций
``	omp_set_dynamic()``, которая уберёт возможность
изменять количество используемых потоков по ходу программы,
и ``omp_set_num_threads()``, которая укажет количество
используемых потоков.

Теперь функция ``Scalar()`` будет выглядеть следующим образом:

````C

static long long i = 0ll;

double Scalar(const Vector* first, const Vector* second) {
    double result = 0.0;
    #pragma omp parallel for default(none) shared(first, second) private(i) reduction(+: result)
    for (i = 0ll; i < DIMENSION; ++i) {
        result += first->x[i] * second->x[i];
    }
    return result;
}

````

### Анализ результатов:

Запуск приложения выполняется из консоли. Для запуска приложению требуется
указать три аргумента: верхнюю границу псевдослучайной величины для первого и
второго векторов, а также требуемое количество потоков, которое нужно
использовать для выполнения программы.

<img src="#" alt="Тут будет скрин из консоли"/>

Тестировалась программа на персональном компьютере со следующими
характеристиками:

* Процессор: Ryzen 5 1600 AF (3.2 Гц, 6 ядер, 12 потоков);
* Видеокарта: GIGABYTE AMD Radeon RX 570 4G AORUS;
* Материнская плата: MSI B450M-A Pro Max;
* Оперативная память: Exceleram 2x8 Гб DDR4 2933 Гц CL19;
* Диски:
  * Western Digital Green SSD 240GB M.2 2280 SATA III 3D NAND TLC;
  * Samsung 860 Evo-Series SSD 500GB 2.5" SATA III V-NAND 3bit MLC.
  
<img src="#" alt="Тут будет диаграмма"/>

Существенное ускорение, очевидно, достигается при использовании всех
"физических потоков" (1 поток на 1 ядро). Незначительный прирост
имеет место аж до использования 10 потоков включительно, далее начинается
понижение производительности, однако оно на уровне погрешности.

Самое существенное ускорение было получено после перехода из
однопоточного режима выполнения программы в режим использование двух
потоков (уменьшение затрат времени с 830 мс до 418 мс).
